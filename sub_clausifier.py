from sub_atomizer import *

def permute_each_time_step(maxTime: int, start: Dict, possvals: List, possasses: List, clauseFuncs: List):
    '''
    For every single time step within the limit, 
    apply the clauses generated by every function in the clauseFuncs list.
    '''
    addedClauses = []
    for t in range(maxTime+1): 
        for gen in clauseFuncs:
            addedClauses.extend(gen(t, start, possvals, possasses)) # t + 1 because value t will start from 0 when it indicates time 1
    return addedClauses

def orig_regs_not_same(start: Dict, val):
    oRNS = [] # original Register containers for the values that are Not the Same as passed in value
    ''' 
    For now this is used in clausifying uniqueness: 
    Finding all possible corresponding start registers s.t. Vy!=val where Vy is the original value of the register. 
    can be useful somewhere else perhaps.
    '''
    for i, key in enumerate(start):
        if val != start[key]:
            oRNS.append(key)
    return oRNS

def clausified_uniqueness(time: int, start: Dict, possvals: List, possasses: List):
    '''
    If Val(Ri,Vx,I) and Vy!=Vx => XVal(R,Vy,I) 
    == X[Val(Ri,Vx,I) ^ Vy!=Vx] v XVal(R,Vy,I) ::: permute Vy over initial register values
    == XVal(R,Vx,I) v XVal (R, Vy, I) ::: should also do this for all possible register states at a given time
    This returns a list of all the corresponding clauses at this time, in a tuple with their meaning.
    '''
    addedClauses = []
    for val_atom in possvals:
        Ra = val_atom[0]
        rawV = val_atom[1]
        oV = val_atom[2] # The original register at time 0 which holds rawV
        Vys = orig_regs_not_same(start, rawV)
        for origReg in Vys:
            meaning = 'If Val({Ra},{rawV},{time}) '\
                'then ~Val({Ra}, {Vy}, {time})'.format(Ra=Ra, rawV=rawV, time=time, origReg=origReg, Vy=start[origReg])
            XVal1 = makeFullAtom(False, Ra, rawV, oV, time, Atom.VAL) 
            XVal2 = makeFullAtom(False, Ra, start[origReg], origReg, time, Atom.VAL)
            addedClauses.append(([XVal1, XVal2], meaning))
    return addedClauses


def clausified_positivity(time: int, start: Dict, possvals: List, possasses: List):
    '''
    (Ass(RA,RB,I)^Val(RB,Vb,I)) -> Val(RA,Vb,I+1) 
    == Ass(RA,RB,I)^(Val(RB,Vb,I) -> Val(RA,Vb,I+1) ::: permutes over all possible values where the register is RB
    == XAss v XVal v Val [via DeMorgans and implication removal]
    '''
    addedClauses = []
    for ass_atom in possasses:
        Ra = ass_atom[0]
        Rb = ass_atom[1]
        for val_atom in possvals:
            R = val_atom[0]
            V = val_atom[1]
            oV = val_atom[2] # original register at time 0 which holds V
            if Rb == R:
               XAss = makeFullAtom()  



def clausified_framing(val: List, state: Dict, time: int): 
    '''
    Frame axiom (no change if no assignment) 
    If Value(R,Vx,I) and not Assign(R,R1,I) and not Assign(R,R2,I) and ... and not Assign(R,Rn,I) then Value(R,Vx,I+1)
    = [Val(R,Vx,I) ^ (XAss(R,Rn,I) [for Rn in all R]) => Val(R, Vx, I+1)
    = X[...] ^ Val(R, Vx, I+1)
    = [XVal(R,Vx,I) v (Ass(R,Rn,I) [for Rn in all R]) v Val(R, Vx, I+1)
    '''
    for reg in state:
        XVal = makeFullAtom(False, Ra, Va, I)
    pass


if __name__ == "__main__":
    try:
        path = sys.argv[1]
    except:
        print("Please input the path of the register requirements.") 
    else:
        reqs = p.read_in(path)
        start = reqs['START']
        goal = reqs['GOAL']
        limit = reqs['LIMIT']
        possasses = permute_possible_assignments(start)
        possvals = permute_possible_values(start)

